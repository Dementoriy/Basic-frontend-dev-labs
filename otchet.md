МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ
РОССИЙСКОЙ ФЕДЕРАЦИИ

ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ
«ВЯТСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ»

Институт математики и информационных систем

Факультет автоматики и вычислительной техники

Кафедра систем автоматизации управления


Дата сдачи на проверку:

«\_\_\_» \_\_\_\_\_\_\_\_\_\_ 2021 г.

Проверено:

«\_\_\_» \_\_\_\_\_\_\_\_\_\_ 2021 г.

**ПОСТРОЕНИЕ ГРАФИКА СИСТЕМЫ УРАВНЕНИЙ**

Отчет по самостоятельной работе № 1
по дисциплине

«Введение в специальность»

Вариант 5



Разработал студент гр. ИТб-1301-01-00	    \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ /Ведерников Д.М./

(Подпись)

Руководитель ст. преподаватель		    \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ /Родионов К.В./

(Подпись)

Работа защищена с оценкой			«\_\_\_\_\_\_\_\_\_\_\_» «\_\_\_» \_\_\_\_\_\_\_\_\_\_ 2021 г.


Киров 2021

Цель: получение навыков построения кусочной функции и разработки программы для нее.

Задание: Создать программу, осуществляющую построение графика системы уравнений


|y=arctg1-x2x            ,при 0<x≤1arctg1-x2x-π, при -1≤x<0 ,|<p></p><p>(1)</p>|
| :-: | :-: |

на ограниченном промежутке по вводимому количеству точек, на языке программирования C#. 

Блок-схема алгоритма, построенная в соответствии с заданием, представлена на рисунке 1.

![](Aspose.Words.3e81560e-fcbc-4138-88f5-0ff642d71927.001.png "Схема\_ввс\_3")

Рисунок 1 – Блок-схема алгоритма построения графика кусочной функции

В соответствии с блок-схемой, представленной на рисунке 1, была реализована программа, строящая график кусочной функции. Листинг этой программы приведен в приложении А.

Идентификаторы программы представлены в таблице 1.


|Назначение|Идентификатор|Тип|
| :-: | :-: | :-: |
|Вычисляемая переменная|y|double|
|Вводимая переменная, отвечающая за количество точек|point|int|
|Массив переменных, отвечающий за координаты X точки (присваивается генератором псевдослучайных чисел)|x|double[ ]|
|Переменная, присваивающая каждому второму значению х отрицательное значение|k|int|
Таблица – 1 Идентификаторы

Результаты работы программы представлены ниже на рисунках 2 – 4. График соединяет точки последовательно, поэтому если точек при вводе будет мало (1–100), то график будет выглядеть незаконченным. Также при повторном вводе такого же количества точек, график может отличаться от предыдущего по той же причине.

![](Aspose.Words.3e81560e-fcbc-4138-88f5-0ff642d71927.002.png)

Рисунок 2 – Результат работы программы при Point = 50

![](Aspose.Words.3e81560e-fcbc-4138-88f5-0ff642d71927.003.png)

Рисунок 3 – Результат работы программы при Point = 100

![](Aspose.Words.3e81560e-fcbc-4138-88f5-0ff642d71927.004.png)

Рисунок 4 – Результат работы программы при Point = 1000

Чтобы проверить правильность вычисления, был произведен запуск программы в режиме отладки и подсчитаны вручную значения y от сгенерированного программой значения х в двух разных промежутках графика. Результаты ручного счета и вычислений программы приведены в таблице 2.

Таблица 2 – Результаты тестирования

|Переменная|Ручной счет|Результат вычисления программы|
| :-: | :-: | :-: |
|x= -0.68483245078699306|y= -3.95802|y= -3.9580152351397286|
|x= 0.78717187549321532|y=0.664586|y= 0.66458649400863767|

Результаты вычислений программы представлены ниже на рисунках 5 и 6.


![](Aspose.Words.3e81560e-fcbc-4138-88f5-0ff642d71927.005.png)

Рисунок 5 – Результат вычисления программы при x<0


![](Aspose.Words.3e81560e-fcbc-4138-88f5-0ff642d71927.006.png)

Рисунок 6 – Результат вычисления программы при x>0


Вывод: в ходе работы были получены навыки построения графика кусочной функции и реализована программа, осуществляющая построение графика заданной системы уравнений, на языке программирования С#. Разработанная программа с поставленной задачей справляется успешно. 































**Приложение А**

` `(обязательное) 

**Листинг программного кода реализации построения графика кусочной функции на языке C#**

using System;

using System.Collections.Generic;

using System.ComponentModel;

using System.Data;

using System.Drawing;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using System.Windows.Forms;

namespace Solution\_5

{

`    `public partial class Form1 : Form

`    `{

`        `public Form1()

`        `{

`            `InitializeComponent();

`        `}

`        `private void button1\_Click(object sender, EventArgs e)

`        `{

`            `double y;

`            `int Point, k = 1;

`            `if ((!int.TryParse(textBox1.Text, out Point))||Point<0)

`            `{

`                `Point = 0;

`                `this.chart1.Series[0].Points.Clear();

`                `this.chart1.Series[1].Points.Clear();

`                `MessageBox.Show("Ошибка ввода");

`            `}

`            `else

`            `{

`                `Point = int.Parse(textBox1.Text);

`            `}

`            `this.chart1.Series[0].Points.Clear();

`            `this.chart1.Series[1].Points.Clear();

`            `double[] x=new double[Point];

`            `Random rnd = new Random();

`            `for (int i = 0; i < Point; i++)

`              `{



`                    `x[i] = rnd.NextDouble();

`                    `if (k % 2 == 0)            

`                      `{         

`                         `x[i] = x[i] \* (-1);

`                         `k = k + 1;

`                       `}

`                    `else k = k + 1;            

`                    `//Алгоритм присваивает каждому второму значению х отрицательное значение             

`               `}

`            `Array.Sort(x);

`            `//Сортировка массива по возрастанию



`            `for (int i = 0; i < Point; i++)

`            `{

`                `if (x[i] > 0 && x[i] <= 1)

`                `{

`                    `y = Math.Atan((Math.Sqrt(1 - x[i] \* x[i]) / x[i]));

`                    `this.chart1.Series[0].Points.AddXY(x[i], y);

`                `}

`                `else

`                `{

`                    `y = Math.Atan((Math.Sqrt(1 - x[i] \* x[i]) / x[i])) - Math.PI;

`                    `this.chart1.Series[1].Points.AddXY(x[i], y);

`                `}

`            `}

`          `}

`    `}

}





















PAGE   \\* MERGEFORMAT8